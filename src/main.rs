/// The number of sides on the dice
/// 
/// This can be changed to any number to calculate the dice for that number of sides.
const SIDES: usize = 8;
/// The number of entries in a probability distribution for two dice with [`SIDES`] sides
const DIST_SIZE: usize = SIDES * 2 - 1;
/// The target dice distribution. The first entry in this array is the number of combinations which should sum to 2, the second is 3, etc.
/// For example, the target distribution for 6-sided dice is `[1, 2, 3, 4, 5, 6, 5, 4, 3, 2, 1]`.
/// This code generates the target distribution programmatically based on [`SIDES`].
///
/// Note: This can be changed to any distribution and the code will still find all valid dice, provided that the value for 2 is not 0.
const TARGET_DISTRIBUTION: [usize; DIST_SIZE] = {
    let mut dist = [0; DIST_SIZE];

    let mut i = 1;
    while i <= SIDES {
        dist[i - 1] = i;
        dist[DIST_SIZE - i] = i;
        i += 1;
    }

    dist
};

/// Checks whether the given distribution has any elements which are greater than the corresponding value in [`TARGET_DISTRIBUTION`].
/// If this is the case, `false` is returned as it is not possible to form valid dice based on this distribution.
fn viable_dist(dist: &[usize; DIST_SIZE]) -> bool {
    for (d, target) in dist.iter().zip(TARGET_DISTRIBUTION.iter()) {
        if d > target {
            return false;
        }
    }

    true
}

/// The sum of two numbers in the input dice was larger than the maximum value in the distribution
struct SumTooLargeError;

/// Calculates the distribution generated by two dice
fn calculate_dist(d1: &[usize], d2: &[usize]) -> Result<[usize; DIST_SIZE], SumTooLargeError> {
    let mut sums = [0; DIST_SIZE];

    for d1s in d1 {
        for d2s in d2 {
            *sums.get_mut(d1s + d2s - 2).ok_or(SumTooLargeError)? += 1;
        }
    }

    Ok(sums)
}

/// Recursively searches for dice which have the correct distribution by building up the dice one number at a time.
/// The algorithm works by finding the smallest result number which does not have enough combinations to match the target distribution.
/// It will attempt to add this number to both dice. If the resulting dice overshoot any numbers in the target distribution, the algorithm
/// stops and backtracks. This continues until the whole search space is completed.
/// 
/// # Parameters
/// * `d1_fixed` and `d2_fixed` are how many elements of each dice have been decided
/// * `d1` and `d2` are the numbers on the dice. The first `d1_fixed` and `d2_fixed` elements respectively are sorted in ascending order.
fn search_recursive(d1: [usize; SIDES], d1_fixed: usize, d2: [usize; SIDES], d2_fixed: usize) {
    // Calculate the distribution for the fixed numbers
    let Ok(dist) = calculate_dist(&d1[0..d1_fixed], &d2[0..d2_fixed]) else {
        return;
    };

    // If the numbers can't form valid dice, don't check any further
    if !viable_dist(&dist) {
        return;
    }

    // If the dice are complete and valid, print them out
    if d1_fixed == SIDES && d2_fixed == SIDES && dist == TARGET_DISTRIBUTION {
        println!("Found valid dice {d1:?} and {d2:?}");
        return;
    }

    // The number to add to one of the dice
    let number_to_add = dist
        .iter()
        .zip(TARGET_DISTRIBUTION.iter())
        .enumerate()
        // Find the first number whose value is lower in the calculated distribution than the target distribution.
        .filter(|(_, (c, t))| c < t)
        // The value of i is the index into the distribution. This is 2 more than the number which needs boosting,
        // But the value on the dice will be combined with a value of 1 on the other dice, so only add 1 here.
        .map(|(i, _)| i + 1)
        .next()
        .unwrap();

    // Whether d2 already has the number. If so, don't add it to d1 as this will lead to the same solution being printed multiple times.
    let d2_has_number = d2_fixed != 0 && d2[d2_fixed - 1] == number_to_add;

    if d1_fixed != SIDES && !d2_has_number {
        let new_d1 = {
            let mut new_d1 = d1;
            new_d1[d1_fixed] = number_to_add;
            new_d1
        };

        search_recursive(new_d1, d1_fixed + 1, d2, d2_fixed)
    }

    // Don't add a number to d2 if d1 and d2 have the same numbers up to this point, as this will lead to the same solution being printed twice with d1 and d2 swapped.
    if d2_fixed != SIDES && d1 != d2 {
        let new_d2 = {
            let mut new_d2 = d2;
            new_d2[d2_fixed] = number_to_add;
            new_d2
        };

        search_recursive(d1, d1_fixed, new_d2, d2_fixed + 1)
    }
}

/// Performs some sanity checks on [`TARGET_DISTRIBUTION`], and sets up the initial call to [`search_recursive`]
fn search() {
    assert_eq!(TARGET_DISTRIBUTION.into_iter().sum::<usize>(), SIDES * SIDES, "The target distribution must sum to the square of the number of sides to be a valid distribution");
    assert!(TARGET_DISTRIBUTION[0] != 0, "The algorithm used to find dice assumes that both dice will have a 1 on them, so the target distribution must have at least one 2.");

    search_recursive([0; SIDES], 0, [0; SIDES], 0)
}

fn main() {
    search()
}
